<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jiwei&#39;s blog</title>
  <subtitle>Walk steps step by step</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http:/"/>
  <updated>2016-11-15T14:44:01.000Z</updated>
  <id>http:/</id>
  
  <author>
    <name>jiwliu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux之进程管理入门</title>
    <link href="http:/2016/05/13/process/"/>
    <id>http:/2016/05/13/process/</id>
    <published>2016-05-12T16:00:00.000Z</published>
    <updated>2016-11-15T14:44:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux进程管理入门。。。</p>
<h2 id="本章关键字"><a href="#本章关键字" class="headerlink" title="本章关键字"></a>本章关键字</h2><p><strong><em> 进程，程序，进程管理，作业控制，守护进程，周期性任务。</em></strong> </p>
<h2 id="本章涉及到的命令"><a href="#本章涉及到的命令" class="headerlink" title="本章涉及到的命令"></a>本章涉及到的命令</h2><p>ps，pgrep，pidof，nohup，pstree，chkconfig，service，systemctl，crontab，at</p>
<h2 id="本章目地"><a href="#本章目地" class="headerlink" title="本章目地"></a>本章目地</h2><p>了解Centos操作系统中的进程，熟悉常用的进程和作业管理，熟悉守护进程和周期性任务的控制管理。<br><a id="more"></a></p>
<h2 id="各小节联系"><a href="#各小节联系" class="headerlink" title="各小节联系"></a>各小节联系</h2><p>第一部分：了解Linux中进程，程序的基本概念；<br>第二部分：对进程和作业进行控制管理；<br>第三部分：对特殊的进程：守护进程进行管理；<br>第四部分：对周期性任务进行控制管理<br><strong><em>(熟悉，了解进程概念—&gt;管理进程—&gt;特殊的进程进行管理(守护进程，周期性任务))</em></strong> </p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h3><h4 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h4><p>进程（process），是计算机中已运行程序的实体，是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。<strong><em> 程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例</em></strong> 。若干进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到内存中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。</p>
<p>进程的概念主要有两点：</p>
<ol>
<li>进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。</li>
<li>进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。</li>
</ol>
<h4 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h4><ol>
<li>程序是指令和数据的有序集合，<strong><em>其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念</em></strong>。</li>
<li>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。</li>
<li>进程更能真实地描述并发，而程序不能；</li>
<li>进程是由进程控制块、程序段、数据段三部分组成;</li>
<li>进程具有创建其他进程的功能，而程序没有。</li>
<li>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程。</li>
<li>在传统的操作系统中，程序并不能独立运行，作为资源分配和独立运行的基本单元都是进程。</li>
</ol>
<h4 id="作业和任务"><a href="#作业和任务" class="headerlink" title="作业和任务"></a>作业和任务</h4><p>用户通过操作系统用户接口（Shell或X环境）提交给计算机进行加工处理的程序。如用户发出一个打印命令，就产生一个打印作业/任务。<br><strong><em> 可以理解为一项任务。</em></strong> </p>
<h4 id="Linux中的进程"><a href="#Linux中的进程" class="headerlink" title="Linux中的进程"></a>Linux中的进程</h4><ol>
<li>每个用户均可同时运行多个程序。为了区分每一个运行的程序，Linux 给每个进程都做了标识，称为进程号（process ID），每个进程的进程号是唯一的。<br>注意：<br><strong><em> 系统启动后的第一个进程是init，它的PID是1;<br>init是唯一一个由系统内核直接运行的进程；<br>新进程可以用系统调用fork来产生；<br>除了init之外，每个进程都有父进程（PPID标识）。</em></strong> </li>
<li>Linux 给每个进程都打上了运行者的标志，用户可以控制自己的进程：给自己的进程分配不同的优先级，也可以随时终止自己的进程。</li>
<li>每个进程还有四个与用户和组相关的识别号<br><strong><em> 实际用户识别号    （real user ID，RUID）<br>实际组识别号        （real group ID，RGID）<br>有效用户识别号    （effect user ID，EUID）<br>有效组识别号        （effect group ID，EGID）</em></strong><br><strong><em> RUID和RGID的作用：</em></strong> 识别正在运行此进程的用户和组，一个进程的RUID和RGID就是运行此进程的UID和GID。<br><strong><em> EUID和EGID的作用：</em></strong> 确定一个进程对其访问的文件的权限。<blockquote>
<ul>
<li>除了产生进程的程序被设置SUID和SGID权限位之外，一般EUID、EGID和RUID、RGID相同。</li>
<li>若程序被设置了SUID或SGID权限位，则此进程相应的EUID和EGID，将和运行此进程的文件的所属用户的UID或所属组的GID相同。</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="进程信号"><a href="#进程信号" class="headerlink" title="进程信号"></a>进程信号</h4><ol>
<li>进程信号是在软件层次上对中断机制的一种模拟，在原理上，<strong><em> 一个进程收到一个信号与处理器收到一个中断请求可以说是一样的；</em></strong> </li>
<li>进程信号是最基本的进程间通讯方式，可以在进程之间直接发送，而不需要用户界面，可以在Shell中通过kill命令发送给进程；</li>
<li>Linux对每种进程信号都规定了默认关联动作;</li>
<li>查看可用的进程信号：<code>kill -l</code><br><img src="/img/process/process11.png" alt="kill -l"></li>
<li>常见的进程信号    <blockquote>
<ul>
<li>SIGTERM | TERM   （15） —— 正常终止 (默认)</li>
<li>SIGKILL | KILL           （9）  —— 立即终止</li>
<li>SIGHUP | HUP          （1）  —— 重读配置文件</li>
</ul>
</blockquote>
</li>
<li>给进程发送信号<blockquote>
<ul>
<li>按PID：kill  [信号]  PID …</li>
<li>按名称：killall  [信号] COMM …</li>
<li>按模式：pkill  [-信号] 模式<br><strong><em> 发送信号可以使用名称或数字号码</em></strong> </li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h4><p>1.交互进程<br><strong><em> 由一个Shell启动的进程</em></strong> ，它既可以在前台运行，也可以在后台运行。<br>2.批处理进程<br><strong><em> 不与特定的终端相关联</em></strong> ，它是需要提交到等待队列种顺序执行的进程。<br>3.守护进程（Daemon）<br>在Linux在启动时初始化，运行于后台的进程（<strong><em> 类似于Windows中的服务</em></strong> ）  </p>
<h4 id="进程启动方式"><a href="#进程启动方式" class="headerlink" title="进程启动方式"></a>进程启动方式</h4><p>1.手工方式：使用操作系统提供的用户接口</p>
<ul>
<li>前台进程：指一个程序控制着标准输入/输出，在程序运行时，shell 被暂时挂起，直到该程序运行结束后，才退回到 shell。在这个过程中，用户不能再执行其它程序。例如：ls -l;</li>
<li>后台进程：在命令最后空格加上“&amp;”，为了避免某些进程长期霸占终端，将其置于后台运行,用户不必等待程序运行结束就可以执行其它程序。例如：ls -R / &gt;list &amp;<br><strong><em> 注意：在一个终端里只能同时存在一个前台任务，但可以有多个后台任务。</em></strong> </li>
</ul>
<p>2.调度方式：按照预先指定的时间执行<br>at，batch，cron</p>
<h4 id="Linux操作系统进程启动顺序"><a href="#Linux操作系统进程启动顺序" class="headerlink" title="Linux操作系统进程启动顺序"></a>Linux操作系统进程启动顺序</h4><p><img src="/img/process/process1.png" alt="Linux操作系统进程启动顺序"></p>
<h3 id="进程管理和作业控制"><a href="#进程管理和作业控制" class="headerlink" title="进程管理和作业控制"></a>进程管理和作业控制</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><p>1.ps命令：查看进程状态信息<br>2.命令格式：ps [选项]<br>不带任何选项的ps命令，会显示当前用户所在终端中的所有进程输出项包括：识别号(PID)、终端(TTY)、运行时间(TIME)、产生该进程所运行的命令(CMD)<br><img src="/img/process/process2.png" alt="ps无参数"><br>3.ps命令的常用选项<br><img src="/img/process/process3.png" alt="ps常用命令选项"><br>4.ps 常见的输出标记<br><img src="/img/process/process4.png" alt="ps常见输出标记"><br>5.ps命令的进程状态列<br><img src="/img/process/process5.png" alt="ps命令的进程状态列"><br>6.常用举例：<br>指定输出列：<code>ps axo  stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm</code><br><img src="/img/process/process7.png" alt="指定输出列"><br>对指定列排序：<code>ps aux --sort -pcpu</code><br><img src="/img/process/process8.png" alt="对指定列排序"><br>搜索进程(使用ps和|grep)：<code>ps -ef | grep ssh</code><br><img src="/img/process/process9.png" alt="对指定列排序"><br><code>ps aux | grep ssh</code><br><img src="/img/process/process10.png" alt="对指定列排序"><br>查找符合条件的PID：<br><code>pgrep ssh</code><br><code>pidof ssh</code></p>
<h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><p>1.杀死进程的原因</p>
<blockquote>
<ul>
<li>该进程占用了过多的CPU时间</li>
<li>该进程锁住了一个终端，使其他前台进程无法运行</li>
<li>运行时间过长，但没有预期效果或无法正常退出</li>
<li>产生了过多到屏幕或磁盘文件的输出</li>
</ul>
</blockquote>
<p>2.杀死进程的命令(<strong><em> 实质是向进程传递进程信号</em></strong> )</p>
<blockquote>
<ul>
<li>通过pid杀死进程    <code>kill 1234 OR kill -9 1234</code></li>
<li>通过名称杀死进程<code>killall myprog OR killall -9 myprog</code></li>
</ul>
</blockquote>
<p><strong><em> 注：kill –9 很霸道，它在杀死一个进程的同时，将杀死其所有子进程，使用时要谨慎。如错杀 login 进程或 shell 进程等。</em></strong> </p>
<h4 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h4><p>作业控制是指控制当前正在运行的进程的行为，也被称为进程控制。<br>1.作业控制常用快捷键/命令（<strong><em> 实质也是在发送进程信号</em></strong> ）</p>
<blockquote>
<ul>
<li>将命令放到后台运行：    <code>cmd &amp;</code></li>
<li>终止一个前台运行的进程（正常终止）：    <code>&lt;Ctrl+d&gt;</code></li>
<li>终止一个前台运行的进程（强行终止）：<code>&lt;Ctrl+c&gt;</code></li>
<li>挂起一个正在前台运行的进程(发送信号17)：<code>&lt;Ctrl+z&gt;</code></li>
<li>显示后台作业和被挂起的进程：<code>jobs</code></li>
<li>在后台恢复一个被挂起的进程：<code>bg</code></li>
<li>在前台恢复一个被挂起的进程：<code>fg</code></li>
</ul>
</blockquote>
<p>2.管理后台作业或暂停的作业 </p>
<blockquote>
<ul>
<li>列举作业号码和名称：jobs<br><img src="/img/process/process12.png" alt="jobs"></li>
</ul>
</blockquote>
<p><strong><em> 注意：+表示默认作业，-表示第二默认作业，第三列表示作业状态，第四列表示作业名</em></strong> </p>
<blockquote>
<ul>
<li>在后台恢复运行：bg [%作业号码]</li>
<li>在前台恢复运行：fg [%作业号码]</li>
</ul>
</blockquote>
<p><strong><em> 注意：bg等同于bg %+，fg等同于fg %+</em></strong> </p>
<blockquote>
<ul>
<li>发送信号：kill -[信号] [％作业号码]<br><img src="/img/process/process13.png" alt="kill"><br>杀死默认作业： kill %+</li>
</ul>
</blockquote>
<h4 id="用户注销后继续运行进程"><a href="#用户注销后继续运行进程" class="headerlink" title="用户注销后继续运行进程"></a>用户注销后继续运行进程</h4><p><strong><em> 通常当用户注销后，所有属于该用户的进程将全部被终止</em></strong> ，如果希望程序在退出系统后仍然能够继续运行，可以使用nohup来启动进程：<br>命令格式：<code>nohup 命令 [选项] [参数] [输出文件] &amp;</code><br>例如：<code>nohup hexo s &amp;</code><br><strong><em> 注意：</em></strong> </p>
<blockquote>
<ul>
<li>若程序有结果输出，输出结果将会被保存到当前目录下的一个文件名为 nohup.out 的文件中， </li>
<li>若用户在当前目录没有写的权限，则结果将会被保存到用户主目录下的 nohup.out 文件中。</li>
</ul>
</blockquote>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><h4 id="守护进程概念"><a href="#守护进程概念" class="headerlink" title="守护进程概念"></a>守护进程概念</h4><h5 id="守护进程-1"><a href="#守护进程-1" class="headerlink" title="守护进程"></a>守护进程</h5><p>始终在后台运行并响应合法请求的程序称为守护（Daemon）进程，类似于windows中的”服务”。</p>
<blockquote>
<ul>
<li>守护进程不是由用户启动运行的，也不与终端关联。</li>
<li>一个实际运行中的系统一般会有多个守护进程在运行，且各个系统中运行的守护进程都不尽相同。</li>
<li>除非程序异常中止或者人为终止，否则它们将一直运行下去直至系统关闭。</li>
</ul>
</blockquote>
<h5 id="守护进程的分类"><a href="#守护进程的分类" class="headerlink" title="守护进程的分类"></a>守护进程的分类</h5><ol>
<li>系统守护进程<blockquote>
<ul>
<li>计划性任务 daemon：如 atd、crond</li>
<li>系统日志 daemon：如 syslogd</li>
<li>网络参数设置 daemon：如 network</li>
</ul>
</blockquote>
</li>
<li>网络守护进程(超级守护进程）<blockquote>
<ul>
<li>各种网络协议侦听 daemon：如：sshd、httpd、sendmail、vsftpd</li>
<li>网络超级服务器（Supper Server）：如：xinetd 或 inetd</li>
</ul>
</blockquote>
</li>
</ol>
<h5 id="网络守护进程的工作原理"><a href="#网络守护进程的工作原理" class="headerlink" title="网络守护进程的工作原理"></a>网络守护进程的工作原理</h5><blockquote>
<ul>
<li><strong><em>网络程序之间的连接是通过端口之间的连接而实现的</em></strong> 。在C/S模型中，服务器监听（Listen）在一个特定的端口上等待客户的连接。连接成功之后客户机与服务器通过端口进行数据通讯。</li>
<li><strong><em>守护进程的工作就是打开一个端口，并且等待并监听（Listen）进入的连接</em></strong> 。如果客户提请了一个连接，<strong><em> 守护进程就创建（fork）子进程来响应此连接，而父进程继续监听更多的服务请求</em></strong> 。因此，每个守护进程都可以处理多个客户服务请求。 </li>
</ul>
</blockquote>
<h5 id="超级服务器的引入"><a href="#超级服务器的引入" class="headerlink" title="超级服务器的引入"></a>超级服务器的引入</h5><p><strong><em> 超级服务器为众多服务创建套接字，并使用Socket系统调用同时监听多个端口</em></strong> ，最广泛使用的就是xinetd（Extended Internet Daemon）</p>
<ul>
<li>对于系统所要提供的每一种网络服务，都必须运行一个监听某个端口连接发生的守护程序，这通常意味着系统资源的浪费。</li>
<li>为了避免系统资源浪费引入了“超级服务器”<blockquote>
<ul>
<li>超级服务器启动后同时监听它所管理的服务的所有端口</li>
<li>当有客户提出服务请求时<ul>
<li>超级服务器会判断这是对哪一个服务的请求，然后再开启与此服务相应的守护进程</li>
<li>由超级服务器产生的某服务的进程处理客户的请求，当处理结束便终止此服务进程</li>
<li>超级服务器本身继续监听其他服务请求</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="守护进程的启动方式"><a href="#守护进程的启动方式" class="headerlink" title="守护进程的启动方式"></a>守护进程的启动方式</h5><ol>
<li>独立启动 <blockquote>
<ul>
<li><strong><em>独立运行的守护进程由init脚本负责管理</em></strong> </li>
<li>独立运行的守护进程的脚本存放在<strong><em> /etc/rc.d/init.d/</em></strong> 目录下</li>
<li>所有的系统服务都是独立运行的。如：crond、syslogd等</li>
<li>一些常用的网络守护进程是独立运行的。如：httpd等</li>
</ul>
</blockquote>
</li>
<li>由超级守护进程运行的守护进程<blockquote>
<ul>
<li>由网络超级服务器（xinetd）运行的守护进程</li>
<li>由xinetd管理的守护进程的配置文件存在/etc/xinetd.d/目录下</li>
<li>默认的xinetd的主配置文件是/etc/xinetd.conf</li>
<li>一些不常用的网络守护进程是由xinetd启动的，如：telnet、 tftp等</li>
<li><strong><em>xinetd本身是独立运行的守护进程</em></strong></li>
</ul>
</blockquote>
</li>
</ol>
<h5 id="查看守护进程列表-pstree"><a href="#查看守护进程列表-pstree" class="headerlink" title="查看守护进程列表:pstree"></a>查看守护进程列表:<code>pstree</code></h5><p><img src="/img/process/process14.png" alt="pstree"></p>
<h4 id="xinetd"><a href="#xinetd" class="headerlink" title="xinetd"></a>xinetd</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>xinetd是新一代的网络守护进程服务程序，提供类似于早期的inetd+tcp_wrapper的功能，与之相比xinetd更加强大和安全。</p>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><blockquote>
<ul>
<li>支持tcp、ucp、RPC协议服务</li>
<li>基于时间段的访问控制</li>
<li>功能完备的log功能，能限制log文件大小</li>
<li>能有效的防止DoS攻击（Denial of Services）</li>
<li>能限制同时运行的同一类型的服务器数目</li>
<li>能限制启动的所有服务器的数目</li>
<li>整合了TCP Wrappers的 libwrap.so库</li>
</ul>
</blockquote>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ol>
<li><p>xinetd的配置文件</p>
<blockquote>
<p>/etc/xinetd.conf<br>/etc/xinetd.d/</p>
</blockquote>
</li>
<li><p>xinetd的常见配置参数</p>
<blockquote>
<p>disable         （xinetd是否监控此服务 ）<br>server          （指定由xinetd监控的服务器路径 ）<br>server_args （指定由xinetd监控的服务器的运行参数）<br>only_from    （只允许指定的主机访问 ）<br>no_access   （指定不能访问的主机）<br>per_source  （每个客户机的最大连接数 ）<br>instances     （服务器总共支持的最高连接数 ）</p>
</blockquote>
</li>
<li>配置举例：/etc/xinetd.d/tftp<pre><code>service tftp
{
  disable                     =    no
  socket_type                =    dgram
  protocol                    =    udp
  wait                        =     yes
  user                        =     root
  server                      =     /usr/sbin/in.tftpd
  server_args                 =     -s /tftpboot
  cps                         =     100 2
  flags                       =     IPv4
  instances                    =     20
  per_source              =     1
  access_times          =     7:00-12:00 13:30-19:00
  only_from               =     192.168.1.0/24
}
</code></pre></li>
</ol>
<h4 id="TCP-Wrappers"><a href="#TCP-Wrappers" class="headerlink" title="TCP Wrappers"></a>TCP Wrappers</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>全称Transmission Control Protocol Wrappers，是一种应用层的网络访问控制程序。它是由 Wietse Venema 开发的一个免费软件。它使用访问控制列表 (ACL) 实现主机访问控制，其中<strong><em> /etc/hosts.allow 是一个许可表，    /etc/hosts.deny 是一个拒绝表</em></strong>  </p>
<h5 id="TCP-Wrappers实现访问控制"><a href="#TCP-Wrappers实现访问控制" class="headerlink" title="TCP Wrappers实现访问控制"></a>TCP Wrappers实现访问控制</h5><blockquote>
<ul>
<li>读取/etc/hosts.allow文件，如果明确允许访问，则提供访问且不再检查/etc/hosts.deny</li>
<li>读取/etc/hosts.deny文件，如果明确拒绝访问，则指定计算机将被拒绝访问。</li>
<li>如果两个文件中都没有访问者的计算机名称或IP地址，则自动提供访问权。</li>
<li>如果不存在这两个文件或文件内容为空，则 TCP_Wrappers的访问控制功能被禁用。</li>
</ul>
</blockquote>
<p><img src="/img/process/process19.png" alt="TCP Wrappers实现访问控制"></p>
<h5 id="TCP-Wrappers与防火墙"><a href="#TCP-Wrappers与防火墙" class="headerlink" title="TCP Wrappers与防火墙"></a>TCP Wrappers与防火墙</h5><blockquote>
<ul>
<li>通常做法是在 Linux 操作系统上安装 Netfilter/iptables 防火墙来处理网络连接。</li>
<li>虽然防火墙有非常广泛的用途，但他却不是万能的。</li>
</ul>
</blockquote>
<p>例如它无法处理类似的向连接发起者发送一些文本这样的任务。TCP Wrappers 能够完成它以及更多的其他事情。</p>
<blockquote>
<ul>
<li>TCP Wrappers 能提供的一些额外的安全功能，但不应被视为好的防火墙的替代品。</li>
<li>TCP Wrappers 应结合防火墙或其他安全加强设施一起使用，为系统多提供一层安全防护。</li>
</ul>
</blockquote>
<p><img src="/img/process/process20.png" alt="TCP Wrappers实现访问控制流程"></p>
<h5 id="TCP-Wrappers的配置文件语法"><a href="#TCP-Wrappers的配置文件语法" class="headerlink" title="TCP Wrappers的配置文件语法"></a>TCP Wrappers的配置文件语法</h5><p>TCP Wrappers的配置文件是/etc/hosts.allow 和 /etc/hosts.deny ，在配置文件中，“#”开始的行为注释；“\” 为续行符<br><img src="/img/process/process21.png" alt="TCP Wrappers的配置文件语法"><br>特殊配置项：</p>
<ul>
<li>宏定义<blockquote>
<ul>
<li>主机名宏定义 <ul>
<li>LOCAL ：本地主机</li>
<li>KNOWN：可解析域名的主机</li>
<li>UNKNOWN：不可解析域名的主机</li>
<li>PARANOID ：IP与其主机名不符的客户</li>
</ul>
</li>
<li>主机和服务宏定义<ul>
<li>ALL </li>
<li>EXCEPT <ul>
<li>可嵌套</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>示例</li>
</ul>
<pre><code>sshd: centos.example.com  192.168.0.254
sshd: .example.com
sshd: .cracker.org EXCEPT trusted.cracker.org
sshd: 123.113.103. 123.113.13.207 LOCAL
sshd: 123.113.103. EXCEPT 123.113.103.207
sshd: 192.168.0.0/255.255.254.0
sshd: 192.168.0.0/23
sshd:  ALL
sshd:  ALL EXCEPT 192.168.1.
sshd:  ALL EXCEPT 192.168.1. PARANOID
sshd:  /etc/acl/mylists.hosts
</code></pre><p><strong><em> 注意：任何修改都立即生效，不需要重新启动服务</em></strong> </p>
<h4 id="守护进程管理工具"><a href="#守护进程管理工具" class="headerlink" title="守护进程管理工具"></a>守护进程管理工具</h4><h5 id="chkconfig-越来越弱了"><a href="#chkconfig-越来越弱了" class="headerlink" title="chkconfig(越来越弱了)"></a>chkconfig(越来越弱了)</h5><p> chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息。谨记chkconfig不是立即自动禁止或激活一个服务，<strong><em> 它只是简单的通过操作/etc/rc[0-6].d目录下的符号连接来实现对各种服务的管理。</em></strong> </p>
<ol>
<li>功能<blockquote>
<ul>
<li>添加指定的新服务</li>
<li>清除指定的服务</li>
<li>显示由chkconfig管理的服务</li>
<li>改变服务的运行级别</li>
<li>检查服务的启动状态</li>
</ul>
</blockquote>
</li>
<li>命令格式<blockquote>
<ul>
<li>chkconfig –list [server-name]</li>
<li>chkconfig –add server-name</li>
<li>chkconfig –del server-name</li>
<li>chkconfig [–level levels] server-name <on|off|reset></on|off|reset></li>
</ul>
</blockquote>
</li>
<li>举例<blockquote>
<ul>
<li>查看指定的服务在所有运行级别的运行状态    <code>chkconfig --list sendmail</code> </li>
<li>显示由chkconfig管理的所有服务<code>chkconfig --list</code></li>
<li>添加一个由chkconfig管理的服务<code>chkconfig --add httpd</code></li>
<li>更改指定服务在指定运行级别的运行状态<code>chkconfig --level 35 httpd on</code></li>
</ul>
</blockquote>
</li>
</ol>
<h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><ol>
<li>在系统运行期间改变守护程序的运行状态</li>
<li>service的命令格式 <blockquote>
<ul>
<li>service –status-all</li>
<li>service server-name status</li>
<li>service  server-name  start|stop|restart</li>
</ul>
</blockquote>
</li>
<li>举例<blockquote>
<ul>
<li>查看系统中的所有守护进程的状态<code>service --status-all</code></li>
<li>查看某个具体的守护进程的状态<code>service nginx status</code><br><img src="/img/process/process17.png" alt="service nginx status"></li>
<li>启动或停止某个守护进程<ul>
<li>独立运行<code>service httpd start|stop|restart</code></li>
<li>由xinetd运行<br><code>chkconfig  tftp  on|off</code><br><code>service xinetd restart</code></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<h5 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h5><p>systemctl是RHEL 7 的服务管理工具中主要的工具，<strong><em> 它融合之前service和chkconfig的功能于一体</em></strong> 。可以使用它永久性或只在当前会话中启用/禁用服务。</p>
<ol>
<li>功能<blockquote>
<p>可以列出正在运行的服务状态<code>systemctl</code><br><img src="/img/process/process15.png" alt="systemctl"><br>systemd-cgls以树形列出正在运行的进程，它可以递归显示控制组内容<code>systemd-cgls</code><br><img src="/img/process/process16.png" alt="systemd-cgls"></p>
</blockquote>
</li>
<li>启动/关闭、启用/禁用服务<blockquote>
<p>启动一个服务：<code>systemctl start postfix.service</code><br>关闭一个服务：<code>systemctl stop postfix.service</code><br>重启一个服务：<code>systemctl restart postfix.service</code><br>显示一个服务的状态：    <code>systemctl status nginx</code><br><img src="/img/process/process18.png" alt="`systemctl status nginx"><br>在开机时启用一个服务：<code>systemctl enable postfix.service</code><br>在开机时禁用一个服务：<code>systemctl disable postfix.service</code><br>查看服务是否开机启动：<code>systemctl is-enabled postfix.service</code><br>查看已启动的服务列表：<code>systemctl list-unit-files|grep enabled</code><br>查看启动失败的服务列表：<code>systemctl --failed</code></p>
</blockquote>
</li>
</ol>
<p><strong><em> 注意：</em></strong> 启用服务就是在当前“runlevel”的配置文件目录<strong><em> /etc/systemd/system/multi-user.target.wants/</em></strong> 里，建立<strong><em> /usr/lib/systemd/system</em></strong> 里面对应服务配置文件的软链接；<strong><em> 禁用服务就是删除此软链接，添加服务就是添加软连接</em></strong> </p>
<h3 id="周期性任务"><a href="#周期性任务" class="headerlink" title="周期性任务"></a>周期性任务</h3><h4 id="cron守护进程"><a href="#cron守护进程" class="headerlink" title="cron守护进程"></a>cron守护进程</h4><h5 id="周期性任务-1"><a href="#周期性任务-1" class="headerlink" title="周期性任务"></a>周期性任务</h5><p>在某个特定时间执行某些命令的行为称为周期性任务； </p>
<h5 id="crond守护进程"><a href="#crond守护进程" class="headerlink" title="crond守护进程"></a>crond守护进程</h5><p>crond守护进程责负责监控周期性任务的执行；它的执行参数保存在/etc/sysconfig/crond中；<br>1.<strong><em> 控制普通用户的使用</em></strong> </p>
<blockquote>
<ul>
<li>若/etc/cron.allow存在，仅列在其中的用户允许使用</li>
<li>若/etc/cron.allow 不存在，检查/etc/cron.deny，没有列于其中的所有用户允许使用</li>
<li>若两个文件均不存在，仅允许root用户使用</li>
<li>空的/etc/cron.deny文件，表示允许所有用户使用（默认值）</li>
</ul>
</blockquote>
<p>2.<strong><em>crond的运行机制</em></strong> </p>
<blockquote>
<ul>
<li>crond守护进程搜索crontab文件并载入内存（ crontab文件即<strong><em> /etc/crontab</em></strong> 文件和 <strong><em> /var/spool/cron/目录下以用户名命名</em></strong> 的文件）</li>
<li>crond守护进程启动以后，它将首先检查是否有用户设置了crontab文件，如果没有就转入休眠状态，释放系统资源 </li>
<li>crond守护进程每分钟醒来一次，查看crontab文件决定当前是否有需要执行的命令。</li>
</ul>
</blockquote>
<p>3.<strong><em>crontab命令</em></strong> </p>
<ul>
<li>作用：用于生成cron进程所需要的crontab文件</li>
<li>命令格式 <blockquote>
<ul>
<li>crontab [-u user] file</li>
<li>crontab [-u user] {-l|-r|-e}<br>ronta-l       在标准输出上显示当前的crontab<br>-r       删除当前的crontab<br>-e 使用编辑器编辑当前的cb文件。当结束编 辑离开时，编辑后的文件将自动安装。<br><strong><em> 任何被允许的用户都可以使用crontab安排任务</em></strong> </li>
</ul>
</blockquote>
</li>
<li><p>crontab文件的格式</p>
<ul>
<li>每一行由5个时间字段及命令组成<br>minute hour  day-of-month  month-of-year  day-of-week  commands</li>
<li><p>五个时间字段 </p>
<blockquote>
<ul>
<li>minute：        一小时中的哪一分钟 [0～59]</li>
<li>hour：            一天中的哪个小时 [0～23]</li>
<li>day-of-month：    一月中的哪一天 [1～31]</li>
<li>month-of-year：    一年中的哪一月 [1～12]</li>
<li>day-of-week：        一周中的哪一天 [0～6]</li>
</ul>
</blockquote>
</li>
<li><p><strong><em>crontab文件的书写注意事项</em></strong></p>
<blockquote>
<ul>
<li>这些项都不能为空，必须填入 </li>
<li>如果用户不需要指定其中的几项时间，那么可以使用统配符- 表示任何时间</li>
<li>每个时间字段都可以指定多个值，它们之间用”,”间隔，如：1,3,5</li>
<li>每个时间字段都可以指定范围，它们之间用“-”间隔 ，如：12-20</li>
<li>每个时间字段都可以使用- /n表示每隔n，如：- /2命令应该给出绝对路，或设置PATH环境变量 </li>
<li>用户必须具有运行所对应的命令或程序的权限</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>系统的 cron 任务</p>
<ul>
<li>crond 守护进程还将搜索系统的cron任务配置文件 /etc/crontab。</li>
<li>使用/etc/crontab 文件为系统管理员安排 cron 任务提供了方便。</li>
<li>以下目录中存放了/etc/crontab 文件运行时执行的文件<blockquote>
<ul>
<li>/etc/cron.hourly/ ：存放每小时要执行的任务文件</li>
<li>/etc/cron.daily/ ：存放每天要执行的任务文件</li>
<li>/etc/cron.weekly/ ：存放每周要执行的任务文件</li>
<li>/etc/cron.monthly/ ：存放每月要执行的任务文件</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>管理员在 /etc/cron.- ly目录下建立脚本文件来安排 cron任务，且在脚本中只需写要安排执行的命令即可<blockquote>
<ul>
<li>/etc/cron.d/ 目录包含额外的系统 crontab 文件</li>
<li>/etc/crontab 文件</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
HOME=/
01 -  -  -  -  root run-parts /etc/cron.hourly
02 4 -  -  -  root run-parts /etc/cron.daily
22 4 -  -  0 root run-parts /etc/cron.weekly
42 4 1 -  -  root run-parts /etc/cron.monthly
</code></pre><h5 id="其他安排周期性任务守护进程和命令"><a href="#其他安排周期性任务守护进程和命令" class="headerlink" title="其他安排周期性任务守护进程和命令"></a>其他安排周期性任务守护进程和命令</h5><p>1.anacron守护进程</p>
<ul>
<li>anacron（anachronistic cron） 是 crond 的一个连续时间版本，它运行计算机关机时 crond 没有运行的任务；</li>
<li>anacron 在 /var/spool/anacron 中保留时间戳文件，记录作业运行的时间；</li>
<li>当 anacron 运行时，它检查自作业上一次运行以来是否已经经过了所需的天数，如果需要，就运行作业；</li>
<li>anacron 的任务表存储在 /etc/anacrontab 文件中。</li>
<li>anacron 的执行过程<blockquote>
<ul>
<li>对于每项任务，anacron 先判定该任务是否已在配置文件的周期字段中指定的期间内被执行了。如果它在给定周期内还没有被执行，anacron 会等待延迟字段中指定的分钟数，然后再次尝试执行命令字段中指定的命令；</li>
<li>当任务完成后，anacron 会将此日期记录在 /var/spool/anacron 目录的时间戳（Timestamp）文件中，默认的时间戳文件有三个：cron.daily，cron.monthly 和 cron.weekly。</li>
</ul>
</blockquote>
</li>
</ul>
<p>2.atd守护进程和at命令<br>atd守护进程负责监控一次性任务的执行，atd守护进程的执行参数保存在/etc/sysconfig/atd配置文件中；</p>
<ul>
<li>控制普通用户的使用<blockquote>
<ul>
<li>若/etc/at.allow存在，仅列在其中的用户允许使用</li>
<li>若/etc/at.allow 不存在，检查/etc/at.deny，没有列于其中的所有用户允许使用</li>
<li>若两个文件均不存在，仅允许root用户使用</li>
<li>空的/etc/at.deny文件，表示允许所有用户使用（默认值）</li>
</ul>
</blockquote>
</li>
<li>at命令的功能和格式<blockquote>
<ul>
<li>功能：安排一个或多个命令在指定的时间运行 一次。</li>
<li>at 命令格式及参数<ul>
<li>at [-q 队列] [-f 文件名] 时间</li>
<li>at -d</li>
<li>at -l</li>
<li>at -c</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Linux进程管理入门。。。&lt;/p&gt;
&lt;h2 id=&quot;本章关键字&quot;&gt;&lt;a href=&quot;#本章关键字&quot; class=&quot;headerlink&quot; title=&quot;本章关键字&quot;&gt;&lt;/a&gt;本章关键字&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt; 进程，程序，进程管理，作业控制，守护进程，周期性任务。&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;h2 id=&quot;本章涉及到的命令&quot;&gt;&lt;a href=&quot;#本章涉及到的命令&quot; class=&quot;headerlink&quot; title=&quot;本章涉及到的命令&quot;&gt;&lt;/a&gt;本章涉及到的命令&lt;/h2&gt;&lt;p&gt;ps，pgrep，pidof，nohup，pstree，chkconfig，service，systemctl，crontab，at&lt;/p&gt;
&lt;h2 id=&quot;本章目地&quot;&gt;&lt;a href=&quot;#本章目地&quot; class=&quot;headerlink&quot; title=&quot;本章目地&quot;&gt;&lt;/a&gt;本章目地&lt;/h2&gt;&lt;p&gt;了解Centos操作系统中的进程，熟悉常用的进程和作业管理，熟悉守护进程和周期性任务的控制管理。&lt;br&gt;
    
    </summary>
    
      <category term="Linux入门教程" scheme="http:/categories/Linux%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http:/tags/Linux/"/>
    
      <category term="进程管理" scheme="http:/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux之网络知识入门</title>
    <link href="http:/2016/05/12/Internet/"/>
    <id>http:/2016/05/12/Internet/</id>
    <published>2016-05-11T16:00:00.000Z</published>
    <updated>2016-11-09T03:34:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Linux网路知识入门。。。</p>
<h3 id="本章关键字"><a href="#本章关键字" class="headerlink" title="本章关键字"></a>本章关键字</h3><p>Linux网络参数，接口设备，设备别名，网络参数配置(临时性(ifconfig,route,hostname,sysctl -w)，永久性(网络接口配置文件))，网络检测工具(ping,netstat,lsof,dig,traceroute)，网络客户工具(lftp,wget,w3m,rsync)，SSH(体系结构，安全验证(基于主机/用户)，SSH免密认证过程)，OpenSSH(ssh,scp,sftp，用户密钥相关文件，密钥的生成，散播，ssh-agent,ssh-add,keychain)，私钥，公钥</p>
<h3 id="本章涉及到的命令"><a href="#本章涉及到的命令" class="headerlink" title="本章涉及到的命令"></a>本章涉及到的命令</h3><p>ifconfig，route，hostname，sysctl -w，lftp，wget，w3m，rsync，ping，netstat，lsof，traceroute，dig，ssh，scp，sftp，ssh-keyscan，ssh-keygen，ssh-add<br><a id="more"></a></p>
<h3 id="本章目地"><a href="#本章目地" class="headerlink" title="本章目地"></a>本章目地</h3><p>了解Linux网络的配置和使用，对Linux环境下网络的使用有个大概了解；</p>
<h3 id="各小节联系"><a href="#各小节联系" class="headerlink" title="各小节联系"></a>各小节联系</h3><p>本章主要分为三个部分，网络基础，网络配置，网络工具(测试工具，客户工具和OpenSSH)；<br>第一部分介绍了Linux中相关的网络背景和网络知识；<br>第二部分讲述了Linux操作系统中对TCP/IP网络参数的配置；<br>第三部分讲述了在Linux操作系统中网络的检测和使用以及远程登录Linux的方法。<br>(熟悉，了解—&gt;配置—&gt;检测，使用)</p>
<h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h3><h4 id="TCP-IP基本知识"><a href="#TCP-IP基本知识" class="headerlink" title="TCP/IP基本知识"></a>TCP/IP基本知识</h4><p><img src="/img/internet/TCP.png" alt="TCP/IP协议簇"></p>
<p>Linux支持各种协议类型的网络(TCP/IP、NetBIOS/NetBEUI、IPX/SPX、AppleTake等),在网络底层也支持Ethernet、Token Ring、ATM、PPP（PPPoE）、FDDI、Frame Relay等网络协议，这些网络协议是Linux内核提供的功能，具体的支持情况由内核编译参数决定；<br><img src="/img/internet/interface.png" alt="Linux内核接口模块"><br>RHEL/CentOS的Linux内核默认支持上述的网络协议；</p>
<p>在TCP/IP网络上，每台设备在存取网络资源之前都需要进行网络配置(IP地址，子网掩码，默认网关，DNS等)，配置方法分为静态配置和动态配置；</p>
<h4 id="网络接口设备与别名"><a href="#网络接口设备与别名" class="headerlink" title="网络接口设备与别名"></a>网络接口设备与别名</h4><h5 id="常见的接口类型"><a href="#常见的接口类型" class="headerlink" title="常见的接口类型"></a>常见的接口类型</h5><pre><code>接口类型        接口名称       说明                    
以太网接口    ethX     是最常用的网络接口                 
令牌环接口    trX     只出现在少数纯IBM环境的网络中            
光纤分布式数据接口    fddiX     FDDI接口设备昂贵，通常用于核心网或高速网络中        
点对点协议接口    pppX     用于Modem/ADSL拨号网络或基于PPTP协议的VPN等        
本地回环接口    lo     用于支持UNIX Domain Socket技术的进程相互通信（IPC）
</code></pre><p><strong><em>注：X是从0开始的整数。如：eth0代表第一块以太网卡，eth1代表第二块以太网卡等。</em></strong></p>
<p>Linux支持众多网络类型的接口，网络接口设备的驱动程序是inux内核的组成部分，Centos默认是采用内核模块的方式再系统引导时驱动网络接口的，系统检测到网卡之后，我们可以到内核模块配置文件中查看系统加载的网卡驱动模块；</p>
<h5 id="设备别名"><a href="#设备别名" class="headerlink" title="设备别名"></a>设备别名</h5><pre><code>使用别名（aliases），单个设备可具备多个地址 
别名被标识为（eth0:1，eth0:2）等等
别名被当作单独的接口对待
基于一块物理网卡的多个别名（包括物理网卡自身）只能有一个接口使用DHCP动态分配网络参数
</code></pre><p>网络接口的启用与停用</p>
<pre><code>使用 ifup ethX 命令来启用指定的接口 
使用 ifdown ethX 命令来禁用指定的接口
</code></pre><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><h4 id="临时性配置-配置后立即生效"><a href="#临时性配置-配置后立即生效" class="headerlink" title="临时性配置(配置后立即生效)"></a>临时性配置(配置后立即生效)</h4><h5 id="可以使用ifconfig开查看并临时配置网络接口"><a href="#可以使用ifconfig开查看并临时配置网络接口" class="headerlink" title="可以使用ifconfig开查看并临时配置网络接口"></a>可以使用ifconfig开查看并临时配置网络接口</h5><p>配置：</p>
<pre><code>ifconfig &lt;网络接口&gt; &lt;IP地址&gt; [Mask &lt;子网掩码&gt;] [Broadcast &lt;广播地址&gt;]
例如：
    # ifconfig eth0 10.0.0.10 Mask 255.255.255.0 Broadcast 10.0.0.255
    # ifconfig eth0 192.168.0.10 
    # ifconfig eth0:0 192.168.1.10
</code></pre><p><strong><em>注:当IP地址使用标准A、B、C类地址时，广播地址和子网掩码可以省略</em></strong><br>查看：</p>
<pre><code>列出已经启动的网络接口：
# ifconfig  
列出全部已经配置的接口(包含已启动和未启动的)：
# ifconfig -a
配置别名设备，并绑定多个IP：
# ifconfig eth0:1 192.168.1,5
# ifconfig eth0:2 192.168.1.7
</code></pre><h5 id="route查看和配置路由"><a href="#route查看和配置路由" class="headerlink" title="route查看和配置路由"></a>route查看和配置路由</h5><p>查看内核路由：</p>
<pre><code># route
</code></pre><p><img src="/img/internet/route.png" alt="route命令"><br>路由的种类：</p>
<pre><code>到主机的路由(Flags字段为H)
到网络的路由(Flags字段为N)
默认网关(Flags字段为G)
</code></pre><p>临时地设置内核路由表：</p>
<pre><code>route add|del [-net|-host] &lt;target [netmask Netmask]&gt; [gw Gateway] [[dev] Interface]
    add或del：表示添加或删除路由
    -net或-host：表示添加到主机或网络的路由
    target：指定目标主机或网络地址，若目标为网络地址时，需使用 netmask 指定子网掩码
    gw：用于指定网关的IP地址
    dev：用于指定路由的网络接口（dev关键字可省略）
添加到主机的路由
# route add -host 10.20.30.148 gw 10.20.30.40
添加到网络的路由
# route add -net 10.20.30.40 netmask 255.255.255.248 eth0
添加默认网关路由
# route add default gw 192.168.1.1
删除到主机的路由
# route del -host 192.168.1.2 dev eth0:0
</code></pre><h5 id="hostname命令可以临时地修改主机名"><a href="#hostname命令可以临时地修改主机名" class="headerlink" title="hostname命令可以临时地修改主机名"></a>hostname命令可以临时地修改主机名</h5><pre><code>格式：hostname &lt;主机名&gt;
例如：# hostname centos.al.co
</code></pre><h5 id="sysctl命令可以临时地开启内核的包转发"><a href="#sysctl命令可以临时地开启内核的包转发" class="headerlink" title="sysctl命令可以临时地开启内核的包转发"></a>sysctl命令可以临时地开启内核的包转发</h5><pre><code>sysctl -w net.ipv4.ip_forward=1
</code></pre><h4 id="永久性配置-配置后重启设备生效"><a href="#永久性配置-配置后重启设备生效" class="headerlink" title="永久性配置(配置后重启设备生效)"></a>永久性配置(配置后重启设备生效)</h4><pre><code>配置文件                                        说明
/etc/sysconfig/network                        系统网络配置文件，包含了主机最基本的网络信息用于系统启动
/etc/sysconfig/network-scripts/ifcfg-ethX    以太网接口配置文件
/etc/sysconfig/network-scripts/route-ethX    以太网接口的静态路由配置文件
/etc/hosts                                    完成主机名映射为IP地址的静态解析功能
/etc/resolv.conf                            配置域名服务客户端的配置文件，用于指定域名服务器的位置
/etc/host.conf                                配置域名服务客户端的控制文件
</code></pre><h5 id="网络设备的配置-etc-sysconfig-network-scripts-ifcfg-ethX"><a href="#网络设备的配置-etc-sysconfig-network-scripts-ifcfg-ethX" class="headerlink" title="网络设备的配置(/etc/sysconfig/network-scripts/ifcfg-ethX)"></a>网络设备的配置(/etc/sysconfig/network-scripts/ifcfg-ethX)</h5><pre><code>选项            说明                        
Type            指定网络接口类型            
DEVICE            指定设备名                    
HWADDR            指定网卡的MAC地址            
BOOTPROTO        指定获取网络参数的方式        
ONBOOT            指定是否在启动时启用设备        
IPADDR            指定静态IP地址
NETMASK            指定子网掩码
BROADCAST        指定广播地址
GATEWAY            指定设备的网关
</code></pre><p>例如：<br>静态配置：</p>
<pre><code>Type=Ethernet
DEVICE=eth0
HWADDR=00:02:8A:A6:30:45
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.0.123
NETMASK=255.255.255.0
BROADCAST=192.168.0.255
GATEWAY=192.168.0.1
</code></pre><p>动态配置：</p>
<pre><code>Type=Ethernet
DEVICE=eth0
HWADDR=00:02:8A:A6:30:45
BOOTPROTO=dhcp
ONBOOT=yes
</code></pre><h5 id="系统网络配置文件-etc-sysconfig-network"><a href="#系统网络配置文件-etc-sysconfig-network" class="headerlink" title="系统网络配置文件(/etc/sysconfig/network)"></a>系统网络配置文件(/etc/sysconfig/network)</h5><p>例如：</p>
<pre><code>NETWORKING=yes
HOSTNAME=centos1.ls-al.loc
GATEWAY=192.168.1.254
</code></pre><h5 id="网络接口的静态路由配置文件-etc-sysconfig-network-scripts-route-ethX"><a href="#网络接口的静态路由配置文件-etc-sysconfig-network-scripts-route-ethX" class="headerlink" title="网络接口的静态路由配置文件(/etc/sysconfig/network-scripts/route-ethX)"></a>网络接口的静态路由配置文件(/etc/sysconfig/network-scripts/route-ethX)</h5><p>每个网络接口均可有其静态路由配置文件 例如：/etc/sysconfig/network-scripts/route-eth0配置文件内加入：</p>
<pre><code>192.168.2.0/24  via  172.16.10.88
</code></pre><h5 id="本地域名解析数据库-etc-hosts"><a href="#本地域名解析数据库-etc-hosts" class="headerlink" title="本地域名解析数据库(/etc/hosts)"></a>本地域名解析数据库(/etc/hosts)</h5><p>例如：</p>
<pre><code>127.0.0.1    localhost.localdomain   localhost
::1          localhost6.localdomain6 localhost6

192.168.1.200    centos1.ls-al.loc   centos1
192.168.0.200    soho.mylabs.me      soho
</code></pre><h5 id="配置远程域名解析器-etc-resolv-conf"><a href="#配置远程域名解析器-etc-resolv-conf" class="headerlink" title="配置远程域名解析器(/etc/resolv.conf)"></a>配置远程域名解析器(/etc/resolv.conf)</h5><p>例如：</p>
<pre><code>nameserver  192.168.1.1
nameverver  208.67.222.222
nameverver  208.67.220.220
domain     sinolido.org        # 指定本机所在的域
search      sinolido.org        # 指定默认搜索域
</code></pre><h5 id="配置域名解析顺序-etc-host-conf"><a href="#配置域名解析顺序-etc-host-conf" class="headerlink" title="配置域名解析顺序(/etc/host.conf)"></a>配置域名解析顺序(/etc/host.conf)</h5><p>例如：首先查找 /etc/hosts 文件进行域名解析，然后使用/etc/resolv.conf文件中指定的域名服务器进行域名解析，/etc/host.conf中配置为：</p>
<pre><code>order hosts,bind
</code></pre><h5 id="设置包转发-etc-sysctl-conf"><a href="#设置包转发-etc-sysctl-conf" class="headerlink" title="设置包转发(/etc/sysctl.conf)"></a>设置包转发(/etc/sysctl.conf)</h5><pre><code>net.ipv4.ip_forward = 1
</code></pre><h3 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h3><h4 id="网络测试工具"><a href="#网络测试工具" class="headerlink" title="网络测试工具"></a>网络测试工具</h4><pre><code>命令工具              功能说明
ifconfig                     检测网络接口配置
route                             检测路由配置
ping                         检测网络连通性
netstat                         查看网络状态
lsof                         查看指定IP 和/或 端口的进程的当前运行情况
host/dig/nslookup             检测DNS解析
traceroute            检测到目的主机所经过的路由器
tcpdump                显示本机网络流量的状态
</code></pre><h5 id="ping：测试网络的连通性"><a href="#ping：测试网络的连通性" class="headerlink" title="ping：测试网络的连通性"></a>ping：测试网络的连通性</h5><pre><code># ping www.baidu.com
</code></pre><h5 id="traceroute：显示数据包到达目的主机所经过的路由"><a href="#traceroute：显示数据包到达目的主机所经过的路由" class="headerlink" title="traceroute：显示数据包到达目的主机所经过的路由"></a>traceroute：显示数据包到达目的主机所经过的路由</h5><pre><code># traceroute www.baidu.com
</code></pre><h5 id="netstat：查看网络端口"><a href="#netstat：查看网络端口" class="headerlink" title="netstat：查看网络端口"></a>netstat：查看网络端口</h5><pre><code># netstate -i //显示网络接口状态信息
# netstate -an //显示监控中的和正在使用的Socket的程序信息
# netstate -nr //显示内核路由表信息
# netstate -lnpt //显示TCP传输协议的连接状态信息
# netstate -lnpu //显示UDP传输协议的连接状态信息
</code></pre><h5 id="lsof：查看在指定IP-和-或-端口上打开的进程"><a href="#lsof：查看在指定IP-和-或-端口上打开的进程" class="headerlink" title="lsof：查看在指定IP 和/或 端口上打开的进程"></a>lsof：查看在指定IP 和/或 端口上打开的进程</h5><pre><code>查看指定端口运行的程序 # lsof -i :22
</code></pre><h5 id="dig：检测DNS解析"><a href="#dig：检测DNS解析" class="headerlink" title="dig：检测DNS解析"></a>dig：检测DNS解析</h5><pre><code>根据/etc/resolv.conf 中的DNS服务器配置查询某域名对应的IP地址/IP对应的域名
# dig wwwbaidu.com 
查询 192.168.0.252 所对应的域名
# dig -x 192.168.0.252
</code></pre><h4 id="网络客户工具"><a href="#网络客户工具" class="headerlink" title="网络客户工具"></a>网络客户工具</h4><pre><code>命令            功能
telnet            远程登录
ftp/lftp/ncftp    FTP工具
smbclient        存取 SMB/CIFS 共享资源（类似于ftp）
wget            下载文件、镜像 WEB站点
rsync            远程文件同步
links/w3m/lynx    浏览器
mutt/mail        邮件客户
ssh/scp/sftp    基于安全协议的 远程登录/远程复制/远程FTP
</code></pre><h5 id="lftp：功能强大的字符界面文件传输工具"><a href="#lftp：功能强大的字符界面文件传输工具" class="headerlink" title="lftp：功能强大的字符界面文件传输工具"></a>lftp：功能强大的字符界面文件传输工具</h5><p>lftp支持传统ftp的所有子命令；<br>lftp还支持如下子命令（常用的）：</p>
<pre><code>help &lt;cmd&gt;：显示指定子命令的帮助信息
get/put/mget/mput：比传统ftp提供更多的选项
pget：多线程下载
reget/reput：续传，等效于 get/put 的 –c 选项
mirror：镜像站点目录
open/close：开始/关闭一个FTP连接
set：设置lftp的环境参数
</code></pre><h5 id="wget：基于控制台的HTTP-FTP下载工具"><a href="#wget：基于控制台的HTTP-FTP下载工具" class="headerlink" title="wget：基于控制台的HTTP/FTP下载工具"></a>wget：基于控制台的HTTP/FTP下载工具</h5><pre><code>wget [option] [&lt;URL-list&gt;]
基本选项：
    选项    说明                选项                说明
    -h    显示命令帮助        -o logfile        将执行过程写入日志文件logfile
    -b    后台执行            -a logfile        将执行过程追加到日志文件logfile
    -v    显示冗余输出        -i urlfile        从urlfile文件读取要下载的文件列表
    -q    不显示执行输出        -O outputfile    将下载的文件改名为outputfile
    -d    显示调试信息        -P PREFIX        将下载的文件存入PREFIX/目录
常用下载选项：
    选项        说明                                    选项                说明
    -t NUM    重试次数为NUM                            --limit-rate=RATE    限制下载速度
    -c        继续未完成的任务                        -m                    镜像站点目录
    -N        开启时间戳比较，仅下载比本地新的文件    -k                    将下载文件中的链接转换为本地的相对链接
    -r        递归下载                                -K                    转换链接前先备份文件
    -l NUM    指定下载深度为NUM                        --user=USER            指定用户名
    -nc        不下载已存在的文件                        --password=PASS        指定用户的口令
    -nd        不在本地创建目录结构                    -L                    仅下载本站相关联的链接
    -np        不遍历父目录                            -H                    可下载外部站点相关文件
    -p        下载HTML页面所包含的所有元素文件        --delete-after        下载后删除本地文件，常用于生成Squid缓存
常用筛选选项：
    选项                                            说明
    -A,  --accept=LIST                    使用逗号间隔的列表指出允许下载的文件扩展名
    -R,  --reject=LIST                    使用逗号间隔的列表指出不允许下载的文件扩展名
    -I,  --include-directories=LIST        使用逗号间隔的列表指出允许下载的目录名
    -X,  --exclude-directories=LIST        使用逗号间隔的列表指出不允许下载的目录名
例如：    
    下载单个文件
    $ wget http://ftp.example.com/pub/getme
    下载单个文件（断点续传）、在后台运行（-b）
    $ wget -cb http://ftp.example.com/isos/somefile.iso
    下载单一HTML文件（-p确保页面显示的所有元素均被下载，-k重新建立链接）
    $ wget -p -k http://esl.jamond.net/index.html
    下载 http://example.com 网站上 packages 目录中的所有文件。(-np 不遍历父目录，-nd 不在本机重新创建目录结构）
    $ wget -r -np -nd http://example.com/packages/
</code></pre><h5 id="rsync：文件同步"><a href="#rsync：文件同步" class="headerlink" title="rsync：文件同步"></a>rsync：文件同步</h5><p>可通过LAN/WAN同步不同主机上的文件或目录，也可以同步本地硬盘中的不同文件或目录；</p>
<p>rsync 使用所谓的 rsync算法 进行数据同步，同步若干新文件时：只复制有变化的文件，同步原有文件时：只复制文件的变化部分；</p>
<p>两种使用方式：</p>
<pre><code>远程Shell方式
    可以使用rsh、ssh等远程Shell，默认使用ssh
    用户验证由远程Shell负责
C/S方式
    客户连接远程 rsync 服务器
    rsync 服务器默认监听 873 端口
    用户验证由 rsync 服务器负责(rsync 服务器也可配置为匿名访问)
    访问rsync服务器时可使用URL（rsync://host）
</code></pre><p>rsync 命令</p>
<pre><code>同步本地文件或目录
    rsync [OPTION...] SRC... [DEST]
将远程文件或目录同步到本地（拉）
    rsync [OPTION...] [USER@]HOST:SRC... [DEST]
将本地文件或目录同步到远程（推）
    rsync [OPTION...] SRC... [USER@]HOST:DEST
    常用选项
        选项                    说明
        -a，--archive        归档模式，等价于 -rlptgoD（不包括-H）
        -r，--recursive        对子目录以递归模式处理
        -l，--links            保持符号链接文件
        -H，--hard-links    保持硬链接文件
        -p，--perms            保持文件权限
        -t，--times            保持文件时间信息
        -g，--group            保持文件属组信息
        -o，--owner            保持文件属主信息（仅 root 可用）
        -D                    保持设备文件和特殊文件（仅 root 可用）
</code></pre><p>举例：</p>
<pre><code>将整个 /home 目录及其子目录同步到  /backups
    # rsync -a --delete /home /backups
将 /home 目录下的所有内容同步到  /backups/home.0
    # rsync -a --delete /home/ /backups/home.0
执行“推”复制同步
    # rsync /etc/hosts centos5:/etc/hosts
执行“拉”复制同步
    # rsync soho:/etc/hosts /etc/hosts
</code></pre><h5 id="links-w3m：字符界面浏览器"><a href="#links-w3m：字符界面浏览器" class="headerlink" title="links/w3m：字符界面浏览器"></a>links/w3m：字符界面浏览器</h5><pre><code>浏览指定的URL
$ links http://www.example.com
$ w3m http://www.example.com
</code></pre><h4 id="SSH与OpenSSH"><a href="#SSH与OpenSSH" class="headerlink" title="SSH与OpenSSH"></a>SSH与OpenSSH</h4><h5 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h5><p>SSH简介</p>
<pre><code>SSH 的英文全称为 Secure SHell
SSH 是建立在应用层和传输层基础上的安全协议
SSH 目的是要在非安全网络上提供安全的远程登录和其他安全服务
    所有使用 SSH 协议的通信，包括口令，都会被加密传输
    用于替代传统的 telnet、ftp、r族命令（rlogin、rsh、rcp）
SSH（Secure SHell）协议是 C/S 模式协议
    分为 SSH 的客户端和服务器端
    一次成功的 SSH 会话需要两端通力合作来完成
</code></pre><p>SSH协议体系结构(见图)</p>
<p><img src="/img/internet/structure.png" alt="SSH协议体系结构"></p>
<p>SSH基于主机的安全验证</p>
<pre><code>在 SSH 协议中每台主机都有一对或多对主机密钥
    首次启动 SSH 服务时会自动生成，一般无需变更
SSH 通过严格的主机密钥检查
    用户可以核对来自服务器的公钥同之前所定义的密钥是否一致，防止了某个用户访问一个他没有相应公钥的主机
    SSH 利用主机的公钥（而不是IP地址）实现主机身份认证，不容易受到IP地址欺骗的攻击
</code></pre><p>SSH基于用户的安全验证</p>
<pre><code>基于口令的安全验证
    只要用户知道自己用户账号和口令，就可以登录到远程主机
    口令验证由 PAM 进行验证
    SSH 对所有传输的数据进行加密传输（包括用户口令）
    不能避免受到“中间人”方式的攻击(冒充真正的服务器)
基于密钥的安全验证
    每个用户都拥有自己的一对或多对密钥
        包括：公钥和私钥
        密钥协议： RSA 或 DSS/DSA
    每个用户自己的密钥对需用户自己生成
        可以使用不同的密钥协议创建多对密钥
        并将公密发布到需要访问的服务器上
    基于密钥的安全验证不需要在网络上传送用户口令
    可以避免“中间人”的攻击方式，因为“中间人”没有你的私钥
</code></pre><p>用户密钥认证协议</p>
<pre><code>RSA 和 DSS/DSA 认证承诺不必提供密码就能够同远程系统建立连接
RSA/DSA 密钥认证协议的基本工作原理： 
    密钥由一对组成：一把专用密钥（亦称私钥）和一把公用密钥（亦称公钥）。
    密钥对由客户端生成，私钥由用户自己保管，并将公钥散播到需要认证之处（登录服务器端）。
    公钥用于对消息进行加密，只有拥有私钥的人才能对该消息进行解密。
    公钥只能用于加密，而私钥只能用于对由匹配的公钥编码的消息进行解密。
</code></pre><p>用户密钥认证过程</p>
<pre><code>SSH 客户向 SSH 服务器提出用户密钥认证请求
SSH 服务器在用户的工作目录下寻找其公钥，然后把它和用户发送过来的公钥进行比较
    如果两个密钥一致
        服务器就用公钥生成加密“质询”（challenge）并把它发送给客户端软件
        客户端软件收到“质询”之后就使用用户自己的私钥解密再把它送还给服务器
        认证通过后，客户端向服务器发送会话请求开始双方的加密会话
    否则认证失败
</code></pre><h5 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h5><p>OpenSSH简介</p>
<pre><code>OpenSSH 是 SSH 协议的免费开源实现
    安全、加密的网络连接工具（ssh、scp、sftp）
    代替了 telnet、 rlogin、rsh、rcp 和 ftp 等工具
OpenSSH 支持 SSH 协议的版本 1和 2。
    自从 OpenSSH 的版本 2.9 以来，默认的协议是版本 2
    版本 2的协议支持 RSA 和 DSA，默认使用 RSA 密钥
OpenSSH 支持的用户认证方式
    支持基于 PAM 的用户口令认证
    支持用户密钥认证 
</code></pre><p>SSH</p>
<pre><code>ssh 用于替代 telnet/rlogin
格式
    ssh [user@]hostname 
    ssh [user@]hostname command 
举例
    $ ssh -l osmond 192.168.0.100
    $ ssh osmond@192.168.0.100
    $ ssh osmond@192.168.0.100 &quot;ls ~&quot; 
</code></pre><p>SCP</p>
<pre><code>scp 用于替代 rcp
格式：scp [option] &lt;source&gt; &lt;destination&gt;
    远程文件的指定方式是：
    [user@]host:/path/to/file
    选项：
    -r：用于递归复制子目录
    -p：用于保留被复制文件的时间戳和权限
    -C：用于压缩数据流
举例
    $ scp osmond@192.168.0.101:remotefile  localfile
    $ scp -rpC osmond@backup.ls-al.me:/data  .
</code></pre><p>Sftp</p>
<pre><code>sftp命令是基于SSH协议的 ftp 的客户端
与 ftp 类似, 但它进行加密传输，比FTP有更高的安全性
格式
    sftp [user@]hostname
举例：
    $ sftp osmond@192.168.0.101
进入 sftp 会话之后就可以使用 ftp 子命令上传和下载文件了
</code></pre><p>OpenSSH的主机密钥生成<br><img src="/img/internet/centos_ssh.png" alt="SSH密钥文件"></p>
<pre><code>OpenSSH的服务启动脚本包含了主机密钥的生成命令,首次启动时默认会生成多对主机密钥（SSH-1 RSA、SSH-2 RSA、SSH-2 DSA）
若系统是从一个旧系统克隆而来,需要重新生成主机密钥
在 RHEL/CentOS 上重新生成主机密钥
    # rm -f /etc/ssh/ssh_host_*
    # service sshd restart
</code></pre><p>OpenSSH密钥生成和分发</p>
<pre><code>密钥生成
    ssh-keygen  [-t rsa1|rsa|dsa]
    默认使用rsa密钥认证类型
密钥分发
    私钥（private key）被保留在自己的系统上
    通常使用口令保护（建议）
    重新设置私钥保护短语
        $ ssh-keygen  -f  ~/.ssh/id_dsa  -p
公钥（public key）被分发（复制）到目标系统
    $ ssh-copy-id -i ~/.ssh/id_dsa.pub [user@]host
</code></pre><p>ssh-agent和ssh-add</p>
<pre><code>ssh-agent
    是一个用户认证代理（authentication agent）
    用于在登录会话中缓存解密后的私钥
    ssh/scp/sftp命令内置支持了同 ssh-agent 通信的机制
    使得私钥保护口令只需要输入一次
    在Shell中运行
        $ eval $(ssh-agent)
        或
        $ ssh-agent bash
    缺点
        每次登录会话都启动一个新的 ssh-agent 副本
            浪费资源
            得使用 ssh-add 向每个新的 ssh-agent 副本添加私钥
        ssh-agent与cron任务系统不兼容
            cron 任务无法从它们的环境中继承 ssh-agent 所需的 SSH_AUTH_SOCK 变量
ssh-add
    用于向认证代理的高速缓存中添加私钥
</code></pre><p>keychain简介</p>
<pre><code>keychain 是一个 ssh-agent 的前端工具
使用keychain完美实现无口令登录
让每个用户只使用一个 ssh-agent 进程
使用一个认证代理可以跨越不同的登录会话
只需对每个私钥执行一次 ssh-add 即可
与 cron任务系统兼容
安装
    # yum  --enablerepo=rpmforge  install  keychain
    # man keychain
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Linux网路知识入门。。。&lt;/p&gt;
&lt;h3 id=&quot;本章关键字&quot;&gt;&lt;a href=&quot;#本章关键字&quot; class=&quot;headerlink&quot; title=&quot;本章关键字&quot;&gt;&lt;/a&gt;本章关键字&lt;/h3&gt;&lt;p&gt;Linux网络参数，接口设备，设备别名，网络参数配置(临时性(ifconfig,route,hostname,sysctl -w)，永久性(网络接口配置文件))，网络检测工具(ping,netstat,lsof,dig,traceroute)，网络客户工具(lftp,wget,w3m,rsync)，SSH(体系结构，安全验证(基于主机/用户)，SSH免密认证过程)，OpenSSH(ssh,scp,sftp，用户密钥相关文件，密钥的生成，散播，ssh-agent,ssh-add,keychain)，私钥，公钥&lt;/p&gt;
&lt;h3 id=&quot;本章涉及到的命令&quot;&gt;&lt;a href=&quot;#本章涉及到的命令&quot; class=&quot;headerlink&quot; title=&quot;本章涉及到的命令&quot;&gt;&lt;/a&gt;本章涉及到的命令&lt;/h3&gt;&lt;p&gt;ifconfig，route，hostname，sysctl -w，lftp，wget，w3m，rsync，ping，netstat，lsof，traceroute，dig，ssh，scp，sftp，ssh-keyscan，ssh-keygen，ssh-add&lt;br&gt;
    
    </summary>
    
      <category term="Linux入门教程" scheme="http:/categories/Linux%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http:/tags/Linux/"/>
    
      <category term="网络" scheme="http:/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
